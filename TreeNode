# python 3

class TreeNode(object):
	
	def __init__(self, key, value, left=None, right=None, parent=None):
		self.key = key
		self.payload = value
		self.left = left
		self.right = right
		self.parent = parent
		
	def hasRightChild(self):
		return self.right is not None
		
	def hasLeftChild(self):
		return self.left is not None
		
	def isRightChild(self):
		return self.parent and self.parent.right == self
		
	def isLefChild(self):
		return self.parent and self.parent.left == self	
		
	def isRoot(self):
		return not self.parent
		
	def hasAnyChildren(self):
		return hasRightChild or hasLeftChild
	
	def hasBothChildre(self):
		return hasRightChild and hasLeftChild
		
		
	def isLeaf(self):
		return not ( self.right and self.left)
		
	def replace(self, node):
		self.key = node.key
		self.payload = node.payload
		self.left  = node.left
		self.right = node.right
		if self.hasRightChild():
			self.right.parent = self
		if self.hasLeftChild():
			self.left.parent = self
		
	def replaceNodeData(self, key, value, lc, rc):
		self.key = key
		self.payload = value
		self.left  = lc
		self.right = rc
		if self.hasRightChild():
			self.right.parent = self
		if self.hasLeftChild():
			self.left.parent = self
			

class BinarySearchTree(object):
    
    """
    Constructor with vaue we are going  to insert in tree with assigning  left and right child with default None 
    """
    
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
        
    """
    If the data we are inserting already present in tree it will not add it to avoid the duplicate values   """
        
    def Add_Node(self, data):
        if data == self.data:
            return # node already exist

        """
        If the data we are inserting is less  than the value of the current node, then data will insert in Left node
        """
        
        if data < self.data:
            if self.left:
                self.left.Add_Node(data)
            else:
                self.left = BinarySearchTree(data)
         
            """
            If the data we are inserting is greater  than the value of the current node, then  data will insert in Right node
            """
            
        else:
            if self.right:
                self.right.Add_Node(data)
            else:
                self.right = BinarySearchTree(data)


    def Find_Node(self, val):
        
        """    If current node is equal to  data we are finding return true   """
        
        if self.data == val:
            return True
        
        """   If current node is lesser than data we are finding we have search in left child node      """

        if val < self.data:
            if self.left:
                return self.left.Find_Node(val)
            else:
                return False
        
        """
        If current node is Greater than data we are finding we have search in right child node    """

        if val > self.data:
            if self.right:
                return self.right.Find_Node(val)
            else:
                return False
            
    """
    First it will visit Left node then it will visit Root node and finally 
    it will visit Right and display a list in specific order
    """        

    def InorderTraversal(self):
        elements = []
        if self.left:
            elements += selfleft.InorderTraversal()

        elements.append(self.data)

        if self.right:
            elements += self.right.InorderTraversal()

        return elements
    
    """
    First it will visit Left node then it will visit Right node and finally 
    it will visit Root node  and display a list in specific order
    """ 
    
    def PostorderTraversal(self):
        elements = []
        if self.left:
            elements += self.left.PostorderTraversal()
        if self.right:
            elements += self.right.PostorderTraversal()

        elements.append(self.data)

        return elements
    
    """
    First it will visit Root node then   it will visit Left node and finally 
    it will visit Right node  and display a  list in specific order
    """   
    
    def PreorderTraversal(self):
        elements = [self.data]
        if self.left:
            elements += self.left.PreorderTraversal()
        if self.right:
            elements += self.right.PreorderTraversal()

        return elements
    
    """
    This method will give the maximum value of tree
    """ 
    
    def Find_Maximum_Node(self):
        if self.right is None:
            return self.data
        return self.right.Find_Maximum_Node()
    
    """
    This method will give the minimum value of tree
    """ 
    
    def Find_Minimum_Node(self):
        if self.left is None:
            return self.data
        return self.left.Find_Minimum_Node()
    
    """
    This method will give the Total Sum value of tree
    """  
    
    def calculateSumNodes(self):
        left_sum = self.left.calculateSumNodes() if self.left else 0
        right_sum = self.right.calculateSumNodes() if self.right else 0
        return self.data + left_sum + right_sum

"""
This method helps to build the tree whith the element we inserted in it
"""

def BuildTree(elements):
    root = BinarySearchTree(elements[0])

    for i in range(1,len(elements)):
        root.Add_Node(elements[i])

    return root
